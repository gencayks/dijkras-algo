<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm - Gencay Kazim Selcuk</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        /* Slide Container */
        .presentation {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            padding: 60px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .slide.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
        }

        /* Typography */
        h1 {
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 2.5rem;
            color: #00d4ff;
            margin-bottom: 30px;
        }

        h3 {
            font-size: 1.8rem;
            color: #e94560;
            margin-bottom: 15px;
        }

        p, li {
            font-size: 1.4rem;
            line-height: 1.8;
            color: #e0e0e0;
        }

        ul {
            list-style: none;
            padding-left: 20px;
        }

        li::before {
            content: "‚ñ∏ ";
            color: #00d4ff;
        }

        .highlight {
            color: #00d4ff;
            font-weight: 600;
        }

        .math {
            font-family: 'Fira Code', monospace;
            background: rgba(0, 212, 255, 0.1);
            padding: 5px 15px;
            border-radius: 5px;
            border-left: 3px solid #00d4ff;
            display: inline-block;
            margin: 10px 0;
        }

        code {
            font-family: 'Fira Code', monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .code-block {
            background: #0d1117;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Fira Code', monospace;
            font-size: 1rem;
            overflow-x: auto;
            border: 1px solid #30363d;
            margin: 15px 0;
        }

        .code-block .keyword { color: #ff7b72; }
        .code-block .type { color: #79c0ff; }
        .code-block .comment { color: #8b949e; }
        .code-block .string { color: #a5d6ff; }
        .code-block .number { color: #79c0ff; }

        /* Layout */
        .content-wrapper {
            display: flex;
            gap: 40px;
            flex: 1;
            align-items: center;
        }

        .text-content {
            flex: 1;
        }

        .visual-content {
            flex: 1;
            height: 100%;
            min-height: 400px;
        }

        /* 3D Canvas */
        #graph3d {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Navigation */
        .nav-bar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 25px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }

        .nav-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #00d4ff;
            background: transparent;
            color: #00d4ff;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: #00d4ff;
            color: #1a1a2e;
        }

        .slide-counter {
            display: flex;
            align-items: center;
            color: #888;
            font-size: 1.2rem;
            padding: 0 20px;
        }

        /* Progress bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            transition: width 0.3s ease;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        th, td {
            padding: 15px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        th {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            font-weight: 600;
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* Animation Classes */
        .fade-in {
            animation: fadeIn 0.8s ease forwards;
        }

        .slide-up {
            animation: slideUp 0.6s ease forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Title Slide */
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title-slide h1 {
            font-size: 5rem;
            margin-bottom: 30px;
        }

        .subtitle {
            font-size: 2rem;
            color: #888;
            margin-bottom: 40px;
        }

        .author {
            font-size: 1.5rem;
            color: #e94560;
        }

        /* Algorithm Steps */
        .step {
            background: rgba(0, 212, 255, 0.1);
            border-left: 4px solid #00d4ff;
            padding: 15px 20px;
            margin: 10px 0;
            border-radius: 0 8px 8px 0;
        }

        .step.active-step {
            background: rgba(233, 69, 96, 0.2);
            border-left-color: #e94560;
        }

        /* Iteration visualization */
        .iteration-table {
            font-size: 1.2rem;
        }

        .iteration-table .updated {
            color: #00ff88;
            font-weight: bold;
        }

        .iteration-table .infinity {
            color: #888;
        }

        .iteration-table .processed {
            background: rgba(0, 255, 136, 0.2);
        }

        /* Keyboard hint */
        .keyboard-hint {
            position: fixed;
            bottom: 100px;
            right: 30px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #888;
        }

        .keyboard-hint kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            margin: 0 3px;
        }

        /* Complexity comparison */
        .complexity-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .complexity-card h4 {
            color: #00d4ff;
            margin-bottom: 15px;
        }

        .big-o {
            font-size: 2.5rem;
            font-family: 'Fira Code', monospace;
            color: #00ff88;
        }

        /* Full screen 3D */
        .full-3d {
            padding: 20px;
        }

        .full-3d .visual-content {
            flex: none;
            width: 100%;
            height: calc(100vh - 150px);
        }

        .overlay-title {
            position: absolute;
            top: 20px;
            left: 60px;
            z-index: 100;
        }

        /* Controls panel */
        .controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 10px 20px;
            margin: 5px 0;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: #00d4ff;
            color: #1a1a2e;
        }

        .control-btn.active {
            background: #e94560;
            border-color: #e94560;
            color: white;
        }

        /* Warning box */
        .warning-box {
            background: rgba(233, 69, 96, 0.2);
            border: 1px solid #e94560;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .warning-box h4 {
            color: #e94560;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progress"></div>
    
    <div class="presentation" id="presentation">
        
        <!-- Slide 1: Title -->
        <div class="slide title-slide active" data-slide="1">
            <h1 class="fade-in">Dijkstra's Algorithm</h1>
            <p class="subtitle slide-up">Finding Shortest Paths in Weighted Graphs</p>
            <p class="author slide-up">Gencay Kazim Selcuk | Mathematics</p>
            <div style="margin-top: 50px; color: #666;">
                <p>Use ‚Üê ‚Üí arrow keys or click buttons to navigate</p>
                <p style="margin-top: 10px;">üñ±Ô∏è Drag to rotate 3D graphs | Scroll to zoom</p>
            </div>
        </div>

        <!-- Slide 2: The Problem -->
        <div class="slide" data-slide="2">
            <h2>üó∫Ô∏è The Problem We're Solving</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <h3>Real-World Applications</h3>
                    <ul>
                        <li><span class="highlight">GPS Navigation</span> - Shortest route from A to B</li>
                        <li><span class="highlight">Network Routing</span> - Internet packet paths</li>
                        <li><span class="highlight">Game AI</span> - NPC pathfinding</li>
                        <li><span class="highlight">Social Networks</span> - Degrees of separation</li>
                    </ul>
                    <div class="math" style="margin-top: 30px;">
                        Given graph G = (V, E) with non-negative weights,<br>
                        find shortest path from source s to all vertices.
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-2"></div>
            </div>
        </div>

        <!-- Slide 3: Graph Basics -->
        <div class="slide" data-slide="3">
            <h2>üìä Graph Terminology</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <table>
                        <tr>
                            <th>Term</th>
                            <th>Definition</th>
                        </tr>
                        <tr>
                            <td>Vertex (Node)</td>
                            <td>A point in the graph</td>
                        </tr>
                        <tr>
                            <td>Edge</td>
                            <td>Connection between vertices</td>
                        </tr>
                        <tr>
                            <td>Weight</td>
                            <td>Cost of traversing an edge</td>
                        </tr>
                        <tr>
                            <td>Path</td>
                            <td>Sequence of edges</td>
                        </tr>
                        <tr>
                            <td>Shortest Path</td>
                            <td>Path with minimum total weight</td>
                        </tr>
                    </table>
                </div>
                <div class="visual-content" id="graph3d-container-3"></div>
            </div>
        </div>

        <!-- Slide 4: Key Insight -->
        <div class="slide" data-slide="4">
            <h2>üí° The Key Insight</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <h3>Greedy Choice Property</h3>
                    <div class="step">
                        <p>"If we always process the unvisited vertex with <span class="highlight">minimum distance</span>, that distance MUST be the final shortest distance."</p>
                    </div>
                    
                    <h3 style="margin-top: 30px;">Why does this work?</h3>
                    <ul>
                        <li>All edge weights are <span class="highlight">non-negative</span></li>
                        <li>Any alternative path goes through unprocessed vertices</li>
                        <li>Those vertices have <span class="highlight">‚â• distance</span></li>
                        <li>Adding non-negative weights only makes paths <span class="highlight">longer</span></li>
                    </ul>
                </div>
                <div class="visual-content" id="graph3d-container-4"></div>
            </div>
        </div>

        <!-- Slide 5: Relaxation -->
        <div class="slide" data-slide="5">
            <h2>‚ö° The Relaxation Operation</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <h3>Core Mathematical Operation</h3>
                    <div class="math" style="font-size: 1.8rem; padding: 20px 30px;">
                        d[v] = min(d[v], d[u] + w(u,v))
                    </div>
                    
                    <h3 style="margin-top: 30px;">What does this mean?</h3>
                    <ul>
                        <li><code>d[v]</code> = current best estimate to vertex v</li>
                        <li><code>d[u]</code> = confirmed shortest distance to u</li>
                        <li><code>w(u,v)</code> = weight of edge from u to v</li>
                    </ul>
                    
                    <div class="step" style="margin-top: 20px;">
                        <strong>Example:</strong> If d[u]=3 and w(u,v)=2:<br>
                        d[v] = min(d[v], 3+2) = min(d[v], 5)<br>
                        If d[v]=7 ‚Üí update to 5 ‚úì<br>
                        If d[v]=4 ‚Üí keep 4 (no improvement)
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-5"></div>
            </div>
        </div>

        <!-- Slide 6: Algorithm Steps -->
        <div class="slide" data-slide="6">
            <h2>üìã Algorithm Steps</h2>
            <div class="content-wrapper">
                <div class="text-content" style="flex: 1.2;">
                    <div class="step">
                        <strong>1. INITIALIZE</strong><br>
                        ‚Ä¢ distance[source] = 0<br>
                        ‚Ä¢ distance[all others] = ‚àû<br>
                        ‚Ä¢ Mark all vertices as unprocessed
                    </div>
                    
                    <div class="step">
                        <strong>2. REPEAT</strong> until all vertices processed:<br>
                        &nbsp;&nbsp;a. SELECT vertex u with minimum distance<br>
                        &nbsp;&nbsp;b. MARK u as processed<br>
                        &nbsp;&nbsp;c. RELAX all edges from u
                    </div>
                    
                    <div class="step">
                        <strong>3. RETURN</strong> distances and parent pointers
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-6"></div>
            </div>
        </div>

        <!-- Slide 7: Interactive 3D Demo -->
        <div class="slide full-3d" data-slide="7">
            <div class="overlay-title">
                <h2>üéÆ Interactive 3D Graph Demo</h2>
            </div>
            <div class="controls-panel">
                <button class="control-btn" onclick="resetGraph()">Reset</button>
                <button class="control-btn" onclick="runDijkstraStep()">Next Step</button>
                <button class="control-btn" onclick="runFullDijkstra()">Run All</button>
                <div style="margin-top: 15px; font-size: 0.9rem; color: #888;">
                    <div id="step-info">Click "Next Step" to begin</div>
                </div>
            </div>
            <div class="visual-content" id="graph3d-main"></div>
        </div>

        <!-- Slide 8: Iteration 1 -->
        <div class="slide" data-slide="8">
            <h2>üìç Iteration 1: Process Vertex 0</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <p>Starting from source vertex <span class="highlight">0</span> (distance = 0)</p>
                    
                    <h3>Relax edges from 0:</h3>
                    <ul>
                        <li>Edge (0,1) weight 4: d[1] = min(‚àû, 0+4) = <span class="highlight">4</span></li>
                        <li>Edge (0,3) weight 2: d[3] = min(‚àû, 0+2) = <span class="highlight">2</span></li>
                    </ul>
                    
                    <table class="iteration-table" style="margin-top: 30px;">
                        <tr>
                            <th>Vertex</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th>
                        </tr>
                        <tr>
                            <td>d[]</td>
                            <td class="processed">0</td>
                            <td class="updated">4</td>
                            <td class="infinity">‚àû</td>
                            <td class="updated">2</td>
                            <td class="infinity">‚àû</td>
                        </tr>
                    </table>
                    
                    <p style="margin-top: 20px;"><strong>Next:</strong> Select vertex 3 (minimum = 2)</p>
                </div>
                <div class="visual-content" id="graph3d-container-8"></div>
            </div>
        </div>

        <!-- Slide 9: Iteration 2 -->
        <div class="slide" data-slide="9">
            <h2>üìç Iteration 2: Process Vertex 3</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <p>Processing vertex <span class="highlight">3</span> (distance = 2)</p>
                    
                    <h3>Relax edges from 3:</h3>
                    <ul>
                        <li>Edge (3,1) w=1: d[1] = min(4, 2+1) = <span class="highlight">3</span> ‚úì Improved!</li>
                        <li>Edge (3,2) w=3: d[2] = min(‚àû, 2+3) = <span class="highlight">5</span></li>
                        <li>Edge (3,4) w=5: d[4] = min(‚àû, 2+5) = <span class="highlight">7</span></li>
                    </ul>
                    
                    <table class="iteration-table" style="margin-top: 30px;">
                        <tr>
                            <th>Vertex</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th>
                        </tr>
                        <tr>
                            <td>d[]</td>
                            <td class="processed">0</td>
                            <td class="updated">3</td>
                            <td class="updated">5</td>
                            <td class="processed">2</td>
                            <td class="updated">7</td>
                        </tr>
                    </table>
                    
                    <div class="step active-step" style="margin-top: 20px;">
                        <strong>Key insight:</strong> Path 0‚Üí3‚Üí1 (cost 3) is shorter than direct 0‚Üí1 (cost 4)!
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-9"></div>
            </div>
        </div>

        <!-- Slide 10: Final Result -->
        <div class="slide" data-slide="10">
            <h2>‚úÖ Final Result</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <table>
                        <tr>
                            <th>Vertex</th>
                            <th>Distance</th>
                            <th>Path</th>
                        </tr>
                        <tr><td>0</td><td>0</td><td>(source)</td></tr>
                        <tr><td>1</td><td>3</td><td>0 ‚Üí 3 ‚Üí 1</td></tr>
                        <tr><td>2</td><td>5</td><td>0 ‚Üí 3 ‚Üí 2</td></tr>
                        <tr><td>3</td><td>2</td><td>0 ‚Üí 3</td></tr>
                        <tr><td>4</td><td>7</td><td>0 ‚Üí 3 ‚Üí 4</td></tr>
                    </table>
                    
                    <h3 style="margin-top: 30px;">Path Reconstruction</h3>
                    <p>Use parent pointers to trace back:</p>
                    <div class="math">
                        To reach 4: parent[4]=3, parent[3]=0<br>
                        Path: 0 ‚Üí 3 ‚Üí 4
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-10"></div>
            </div>
        </div>

        <!-- Slide 11: C Implementation -->
        <div class="slide" data-slide="11">
            <h2>üíª C Implementation: Data Structures</h2>
            <div class="content-wrapper">
                <div class="text-content" style="flex: 1.3;">
                    <div class="code-block">
<span class="comment">/* Edge in adjacency list */</span>
<span class="keyword">typedef struct</span> <span class="type">Edge</span> {
    <span class="type">int</span> destination;    <span class="comment">/* Target vertex */</span>
    <span class="type">int</span> weight;         <span class="comment">/* Edge weight */</span>
    <span class="keyword">struct</span> <span class="type">Edge</span> *next;  <span class="comment">/* Next edge */</span>
} <span class="type">Edge</span>;

<span class="comment">/* Graph structure */</span>
<span class="keyword">typedef struct</span> <span class="type">Graph</span> {
    <span class="type">int</span> num_vertices;   <span class="comment">/* |V| */</span>
    <span class="type">int</span> num_edges;      <span class="comment">/* |E| */</span>
    <span class="type">Edge</span> **adj_list;   <span class="comment">/* Adjacency lists */</span>
} <span class="type">Graph</span>;
                    </div>
                    
                    <h3>Why Adjacency List?</h3>
                    <ul>
                        <li><strong>Space:</strong> O(V + E) vs O(V¬≤) for matrix</li>
                        <li><strong>Neighbors:</strong> O(degree) vs O(V)</li>
                    </ul>
                </div>
                <div class="visual-content" id="graph3d-container-11"></div>
            </div>
        </div>

        <!-- Slide 12: Core Algorithm Code -->
        <div class="slide" data-slide="12">
            <h2>üíª C Implementation: Core Algorithm</h2>
            <div class="content-wrapper">
                <div class="text-content" style="flex: 1.5;">
                    <div class="code-block">
<span class="comment">/* Find minimum distance unprocessed vertex */</span>
<span class="type">int</span> find_min_vertex(<span class="type">int</span> *distance, <span class="type">bool</span> *processed, <span class="type">int</span> n) {
    <span class="type">int</span> min_dist = INF, min_v = -<span class="number">1</span>;
    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v < n; v++) {
        <span class="keyword">if</span> (!processed[v] && distance[v] < min_dist) {
            min_dist = distance[v];
            min_v = v;
        }
    }
    <span class="keyword">return</span> min_v;
}

<span class="comment">/* Relaxation step */</span>
<span class="keyword">if</span> (distance[u] + weight < distance[v]) {
    distance[v] = distance[u] + weight;
    parent[v] = u;
}
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-12"></div>
            </div>
        </div>

        <!-- Slide 13: Complexity -->
        <div class="slide" data-slide="13">
            <h2>‚è±Ô∏è Complexity Analysis</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <table>
                        <tr>
                            <th>Implementation</th>
                            <th>EXTRACT-MIN</th>
                            <th>DECREASE-KEY</th>
                            <th>Total</th>
                        </tr>
                        <tr>
                            <td>Array</td>
                            <td>O(V)</td>
                            <td>O(1)</td>
                            <td class="highlight">O(V¬≤)</td>
                        </tr>
                        <tr>
                            <td>Binary Heap</td>
                            <td>O(log V)</td>
                            <td>O(log V)</td>
                            <td class="highlight">O((V+E) log V)</td>
                        </tr>
                        <tr>
                            <td>Fibonacci Heap</td>
                            <td>O(log V)*</td>
                            <td>O(1)*</td>
                            <td class="highlight">O(V log V + E)</td>
                        </tr>
                    </table>
                    <p style="color: #888; font-size: 1rem;">* amortized</p>
                    
                    <div style="display: flex; gap: 20px; margin-top: 30px;">
                        <div class="complexity-card">
                            <h4>Dense Graphs</h4>
                            <p>E ‚âà V¬≤</p>
                            <p class="big-o">O(V¬≤)</p>
                            <p>Use Array</p>
                        </div>
                        <div class="complexity-card">
                            <h4>Sparse Graphs</h4>
                            <p>E ‚âà V</p>
                            <p class="big-o">O(V log V)</p>
                            <p>Use Heap</p>
                        </div>
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-13"></div>
            </div>
        </div>

        <!-- Slide 14: Limitations -->
        <div class="slide" data-slide="14">
            <h2>‚ö†Ô∏è Important Limitations</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <div class="warning-box">
                        <h4>Dijkstra REQUIRES Non-Negative Weights!</h4>
                        <p>With negative edges, the greedy choice fails.</p>
                    </div>
                    
                    <h3>Example of Failure:</h3>
                    <div class="code-block">
        (A)
       /   \
      2    -5
     /       \
   (S)        (C)
     \       /
      3     1
       \   /
        (B)
                    </div>
                    <ul>
                        <li>Dijkstra finds: S‚ÜíB‚ÜíC = <span class="highlight">4</span></li>
                        <li>But S‚ÜíA‚ÜíC = 2 + (-5) = <span class="highlight">-3</span> is shorter!</li>
                    </ul>
                    
                    <div class="step" style="margin-top: 20px;">
                        <strong>Solution:</strong> Use <span class="highlight">Bellman-Ford</span> for negative weights
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-14"></div>
            </div>
        </div>

        <!-- Slide 15: Summary -->
        <div class="slide" data-slide="15">
            <h2>üìö Summary</h2>
            <div class="content-wrapper">
                <div class="text-content">
                    <h3>What We Learned</h3>
                    <ul>
                        <li><strong>Problem:</strong> Finding shortest paths in weighted graphs</li>
                        <li><strong>Key Insight:</strong> Greedy choice with relaxation</li>
                        <li><strong>Algorithm:</strong>
                            <ul style="margin-left: 20px;">
                                <li>Initialize distances (source=0, others=‚àû)</li>
                                <li>Extract minimum, relax neighbors</li>
                                <li>Build shortest path tree</li>
                            </ul>
                        </li>
                        <li><strong>Complexity:</strong> O(V¬≤) or O((V+E) log V)</li>
                        <li><strong>Limitation:</strong> Non-negative weights only!</li>
                    </ul>
                    
                    <div class="math" style="margin-top: 30px; font-size: 1.5rem;">
                        d[v] = min(d[v], d[u] + w(u,v))
                    </div>
                </div>
                <div class="visual-content" id="graph3d-container-15"></div>
            </div>
        </div>

        <!-- Slide 16: Thank You -->
        <div class="slide title-slide" data-slide="16">
            <h1 class="fade-in">Thank You!</h1>
            <p class="subtitle slide-up">Questions?</p>
            <p style="color: #00d4ff; margin-top: 20px;">Presented by Gencay Kazim Selcuk</p>
            <div style="margin-top: 40px;">
                <p>Code available in:</p>
                <p><code>dijkstra.h</code> <code>graph.c</code> <code>dijkstra.c</code> <code>main.c</code></p>
            </div>
            <div style="margin-top: 40px;">
                <div class="code-block" style="display: inline-block;">
make && ./dijkstra
                </div>
            </div>
        </div>
    </div>

    <div class="nav-bar">
        <button class="nav-btn" onclick="prevSlide()">‚Üê</button>
        <div class="slide-counter">
            <span id="current-slide">1</span> / <span id="total-slides">16</span>
        </div>
        <button class="nav-btn" onclick="nextSlide()">‚Üí</button>
    </div>

    <div class="keyboard-hint">
        <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> Navigate &nbsp;|&nbsp; <kbd>F</kbd> Fullscreen
    </div>

    <script>
        // ============================================
        // PRESENTATION NAVIGATION
        // ============================================
        let currentSlide = 1;
        const totalSlides = document.querySelectorAll('.slide').length;
        document.getElementById('total-slides').textContent = totalSlides;

        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            
            if (n > totalSlides) currentSlide = 1;
            if (n < 1) currentSlide = totalSlides;
            
            slides.forEach(slide => {
                slide.classList.remove('active');
            });
            
            slides[currentSlide - 1].classList.add('active');
            document.getElementById('current-slide').textContent = currentSlide;
            document.getElementById('progress').style.width = 
                ((currentSlide / totalSlides) * 100) + '%';
            
            // Initialize 3D graph for current slide if needed
            initSlideGraph(currentSlide);
        }

        function nextSlide() {
            currentSlide++;
            showSlide(currentSlide);
        }

        function prevSlide() {
            currentSlide--;
            showSlide(currentSlide);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                prevSlide();
            } else if (e.key === 'f' || e.key === 'F') {
                toggleFullscreen();
            }
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // ============================================
        // 3D GRAPH VISUALIZATION
        // ============================================
        
        // Graph data
        const graphData = {
            vertices: [
                { id: 0, label: '0', x: -2, y: 0, z: 0 },
                { id: 1, label: '1', x: 0, y: 2, z: 0 },
                { id: 2, label: '2', x: 2, y: 1, z: 0 },
                { id: 3, label: '3', x: 0, y: -1, z: 1 },
                { id: 4, label: '4', x: 2, y: -1, z: 1 }
            ],
            edges: [
                { from: 0, to: 1, weight: 4 },
                { from: 0, to: 3, weight: 2 },
                { from: 1, to: 2, weight: 2 },
                { from: 1, to: 3, weight: 1 },
                { from: 2, to: 3, weight: 3 },
                { from: 2, to: 4, weight: 6 },
                { from: 3, to: 4, weight: 5 }
            ]
        };

        // Store all scene instances
        const scenes = {};
        const cameras = {};
        const renderers = {};
        const controls = {};
        const graphObjects = {};

        // Dijkstra state for interactive demo
        let dijkstraState = {
            distances: [0, Infinity, Infinity, Infinity, Infinity],
            processed: [false, false, false, false, false],
            parents: [-1, -1, -1, -1, -1],
            currentStep: 0,
            currentVertex: -1
        };

        // Colors
        const colors = {
            vertex: 0x00d4ff,
            vertexProcessed: 0x00ff88,
            vertexCurrent: 0xe94560,
            edge: 0x444466,
            edgeHighlight: 0x00d4ff,
            edgeRelaxed: 0x00ff88,
            text: 0xffffff
        };

        function create3DGraph(containerId, highlightState = {}) {
            const container = document.getElementById(containerId);
            if (!container || container.offsetWidth === 0) return null;
            
            // Clean up existing scene
            if (scenes[containerId]) {
                while(scenes[containerId].children.length > 0) {
                    scenes[containerId].remove(scenes[containerId].children[0]);
                }
            }

            const width = container.offsetWidth;
            const height = container.offsetHeight;

            // Scene
            const scene = new THREE.Scene();
            scenes[containerId] = scene;

            // Camera
            const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera.position.set(5, 3, 5);
            cameras[containerId] = camera;

            // Renderer
            let renderer = renderers[containerId];
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                renderer.setClearColor(0x000000, 0);
                container.appendChild(renderer.domElement);
                renderers[containerId] = renderer;
            } else {
                renderer.setSize(width, height);
            }

            // Controls
            const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.autoRotate = true;
            orbitControls.autoRotateSpeed = 0.5;
            controls[containerId] = orbitControls;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // Create vertices
            const vertexMeshes = [];
            graphData.vertices.forEach((v, i) => {
                let color = colors.vertex;
                if (highlightState.processed && highlightState.processed[i]) {
                    color = colors.vertexProcessed;
                }
                if (highlightState.current === i) {
                    color = colors.vertexCurrent;
                }

                const geometry = new THREE.SphereGeometry(0.3, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(v.x, v.y, v.z);
                scene.add(sphere);
                vertexMeshes.push(sphere);

                // Add glow effect
                const glowGeometry = new THREE.SphereGeometry(0.4, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(sphere.position);
                scene.add(glow);

                // Label
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(v.label, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(v.x, v.y + 0.5, v.z);
                sprite.scale.set(0.5, 0.5, 1);
                scene.add(sprite);
            });

            // Create edges
            graphData.edges.forEach(e => {
                const from = graphData.vertices[e.from];
                const to = graphData.vertices[e.to];

                let edgeColor = colors.edge;
                if (highlightState.relaxedEdges) {
                    highlightState.relaxedEdges.forEach(re => {
                        if ((re.from === e.from && re.to === e.to) ||
                            (re.from === e.to && re.to === e.from)) {
                            edgeColor = colors.edgeRelaxed;
                        }
                    });
                }

                // Edge line
                const points = [
                    new THREE.Vector3(from.x, from.y, from.z),
                    new THREE.Vector3(to.x, to.y, to.z)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: edgeColor,
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);

                // Edge weight label
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2 + 0.3;
                const midZ = (from.z + to.z) / 2;

                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#00d4ff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(e.weight.toString(), 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(midX, midY, midZ);
                sprite.scale.set(0.4, 0.4, 1);
                scene.add(sprite);
            });

            graphObjects[containerId] = { scene, camera, renderer, controls: orbitControls, vertexMeshes };

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                orbitControls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                const newWidth = container.offsetWidth;
                const newHeight = container.offsetHeight;
                if (newWidth > 0 && newHeight > 0) {
                    camera.aspect = newWidth / newHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(newWidth, newHeight);
                }
            });

            return { scene, camera, renderer };
        }

        // Initialize graph for each slide
        function initSlideGraph(slideNum) {
            setTimeout(() => {
                const containerMap = {
                    2: 'graph3d-container-2',
                    3: 'graph3d-container-3',
                    4: 'graph3d-container-4',
                    5: 'graph3d-container-5',
                    6: 'graph3d-container-6',
                    7: 'graph3d-main',
                    8: 'graph3d-container-8',
                    9: 'graph3d-container-9',
                    10: 'graph3d-container-10',
                    11: 'graph3d-container-11',
                    12: 'graph3d-container-12',
                    13: 'graph3d-container-13',
                    14: 'graph3d-container-14',
                    15: 'graph3d-container-15'
                };

                const containerId = containerMap[slideNum];
                if (!containerId) return;

                let highlightState = {};
                
                // Different highlight states for different slides
                if (slideNum === 8) {
                    highlightState = {
                        processed: [true, false, false, false, false],
                        current: 0
                    };
                } else if (slideNum === 9) {
                    highlightState = {
                        processed: [true, false, false, true, false],
                        current: 3,
                        relaxedEdges: [{ from: 3, to: 1 }, { from: 3, to: 2 }, { from: 3, to: 4 }]
                    };
                } else if (slideNum === 10) {
                    highlightState = {
                        processed: [true, true, true, true, true],
                        relaxedEdges: [
                            { from: 0, to: 3 },
                            { from: 3, to: 1 },
                            { from: 3, to: 2 },
                            { from: 3, to: 4 }
                        ]
                    };
                }

                create3DGraph(containerId, highlightState);
            }, 100);
        }

        // ============================================
        // INTERACTIVE DIJKSTRA DEMO (Slide 7)
        // ============================================
        
        function resetGraph() {
            dijkstraState = {
                distances: [0, Infinity, Infinity, Infinity, Infinity],
                processed: [false, false, false, false, false],
                parents: [-1, -1, -1, -1, -1],
                currentStep: 0,
                currentVertex: -1
            };
            document.getElementById('step-info').innerHTML = 'Click "Next Step" to begin';
            create3DGraph('graph3d-main', {});
        }

        function runDijkstraStep() {
            const state = dijkstraState;
            
            if (state.currentStep >= 5) {
                document.getElementById('step-info').innerHTML = 
                    '<span style="color: #00ff88;">Algorithm complete!</span>';
                return;
            }

            // Find minimum unprocessed vertex
            let minDist = Infinity;
            let minVertex = -1;
            for (let v = 0; v < 5; v++) {
                if (!state.processed[v] && state.distances[v] < minDist) {
                    minDist = state.distances[v];
                    minVertex = v;
                }
            }

            if (minVertex === -1) {
                document.getElementById('step-info').innerHTML = 
                    '<span style="color: #00ff88;">Algorithm complete!</span>';
                return;
            }

            state.currentVertex = minVertex;
            state.processed[minVertex] = true;

            // Get neighbors and relax
            const relaxedEdges = [];
            const neighbors = graphData.edges.filter(e => 
                e.from === minVertex || e.to === minVertex
            );

            let infoText = `Processing vertex <span style="color:#e94560">${minVertex}</span> (d=${minDist})<br>`;

            neighbors.forEach(e => {
                const neighbor = e.from === minVertex ? e.to : e.from;
                if (!state.processed[neighbor]) {
                    const newDist = state.distances[minVertex] + e.weight;
                    if (newDist < state.distances[neighbor]) {
                        state.distances[neighbor] = newDist;
                        state.parents[neighbor] = minVertex;
                        relaxedEdges.push({ from: minVertex, to: neighbor });
                        infoText += `‚Üí d[${neighbor}] = ${newDist}<br>`;
                    }
                }
            });

            state.currentStep++;
            document.getElementById('step-info').innerHTML = infoText;

            create3DGraph('graph3d-main', {
                processed: [...state.processed],
                current: minVertex,
                relaxedEdges: relaxedEdges
            });
        }

        function runFullDijkstra() {
            resetGraph();
            let step = 0;
            const interval = setInterval(() => {
                runDijkstraStep();
                step++;
                if (step >= 5) clearInterval(interval);
            }, 1000);
        }

        // Initialize first slide
        showSlide(1);
    </script>
</body>
</html>
